# 🧠 MESI Cache Coherence Simulator

This project implements a simplified multiprocessor cache subsystem that models the **MESI (Modified, Exclusive, Shared, Invalid)** cache coherence protocol using SystemVerilog. Each cache controller maintains local cache states and communicates via a centralized **snoopy bus** to uphold coherence on shared memory lines.

🛠️ **Currently building a UVM-based testbench** to verify coherence transitions.

---

## 🧩 Architecture Overview

The simulation consists of the following components:

- **cache_controller**: A parameterized MESI finite state machine
- **snoopy_bus**: Observes read/write requests and generates snoop signals
- **top_system**: Instantiates and connects multiple caches and the bus
- **testbench**: Applies basic read/write stimulus and monitors cache states

---

## 🔗 Cache Interface Signals

Each cache controller interacts with:
- **Inputs**:
  - `clk`, `rst`: Clock and reset
  - `read_req`, `write_req`: Initiate cache access
  - `addr`: Memory address being accessed
  - `snoop_read`, `snoop_read_excl`, `snoop_invalidate`: Snoop signals from bus
- **Outputs**:
  - `mem_read`, `mem_write`: Signals to memory (flushes, loads)
  - `state`: Current MESI state

---

## 🌐 MESI Protocol States

| Code | State      | Description                                   |
|------|------------|-----------------------------------------------|
| 00   | INVALID    | No valid data; must fetch from memory         |
| 01   | SHARED     | Valid data; possibly shared with others       |
| 10   | EXCLUSIVE  | Valid data; only copy in system               |
| 11   | MODIFIED   | Only copy; has been modified; must be flushed |

---

## 🔁 State Transitions

Some key examples:
- `INVALID → EXCLUSIVE` when a read occurs and no one else has the data
- `SHARED → MODIFIED` on a write
- `MODIFIED → SHARED/INVALID` on snoop read/snoop exclusive
- Snoop signals are generated by checking address conflicts across caches

---

## 🧪 Current Testbench Behavior

The testbench simulates:
- Cache0 performs a `read` to address `0x1000`
- Cache1 performs a `write` to the same address after a delay
- Observes MESI state transitions and memory activity
  
## 🧮 UVM Testbench (In Progress)

---

## 📚 Learning Goals

This project is great for:

- Understanding coherence in multicore systems  
- Modeling bus-based protocols  
- Practicing RTL design with state machines  
- Building toward formal UVM verification  

---

## 🤝 Contributing

Interested in improving or extending this project (e.g., MOESI support or memory model)?  
Feel free to fork and submit a pull request!

---

## 👤 Author

**Sri Durga Raju**  
📬 Reach me on [LinkedIn]() 

